\section{Introduction}

\review
{
	State the objectives of the assignment. Summarise briefly your preparation work,  your experimental work,, and results achieved. Specifically, state which parts of the assignment were delivered according to the requirements and summarise any extensions to the basic specification you have carried out with references to the sections.  ( approx. 0.5 page).
}

The objective of this project was to design and build a picoMIPS processor capable of performing an affine transform of a two dimensional coordinate. This is equivalent to the matrix transformation of Equation \ref{eq:affine-transform}
\begin{equation}
\begin{bmatrix}
x_2\\
y_2
\end{bmatrix}
=
\begin{bmatrix}
A_{11} & A_{12}\\
A_{21} & A_{22}
\end{bmatrix}
\begin{bmatrix}
x_1\\
y_1
\end{bmatrix}
+
\begin{bmatrix}
B_1\\
B_2
\end{bmatrix}
\label{eq:affine-transform}
\end{equation}

The goal of the exercise is to create a design as minimal as possible, but capable of implementing this affine transform. The size of the implementation is defined by the cost figure of Equation \ref{eq:cost}.

\begin{equation}
	\text{Cost} = [\text{Number of Logic Elements}] + \max([\text{Number of 9bit Multipliers}] -2, 0) + \frac{ [\text{Bits of RAM}]}{1024} \times 30
	\label{eq:cost}
\end{equation}

In preparation for the assignment I conducted research into minimal instruction set computers, and designed my system on paper. The design of the instruction set is Summarised in section \ref{sec:instructions}, and the design of the remainder of the system is discussed therein as well as in subsequent sections.

As an extension exercise I wrote SystemVerilog code to convert the signed 8-bit words on the switches and LEDs to binary coded decimal and then display this using the seven segment displays present on the development board. This is discussed briefly in Section \ref{sec:implementation}.

\review{Mention size tests and investigation into logic element usage}

\section{Instruction format, decoder design, program memory, and program counter} \label{sec:instructions}

\subsection{System overview}

A block diagram showing my picoMIPS implementation is shown in Figure \ref{fig:final-proc-arch}. In this diagram, blue lines show address signals, red shows data signals, and green shows control signals. The cycle counter is a four bit, one hot encoded counter, and controls the flow of data across four clock cycles, which make up one instruction cycle. The four cycles are fetch, decode 1, decode 2, and execute. A timing diagram showing the execution of the processor across these cycles is shown in Figure \ref{fig:proc-timing-diagram}. During the fetch stage, the program counter is valid and so the new instruction will be fetched from the program memory on the next clock edge. During the two decode cycles, the processor retrieves the values of the two data registers from memory. Two cycles are necessary for this because the Cyclone IV memory architecture only support dual port \glspl{ram} and \glspl{rom}. Therefore two clock cycles must be used in order to read from two data addresses.

During the execute cycle, the data values are valid, and so the ALU can calculate the result. The ALU is combinational, and so the branch flag and write data are valid on the next clock edge. This means that the program counter can be set to the new value, and the data can be written to the relevant register.

\begin{figure}[ht]
	\centering
	\begin{tikztimingtable}%[ xscale=0.8, yscale=1.5]
		Clock			& L 12{2C} C \\
		Cycle			& D{} 2{ 4D{Decode} 4D{Execute} 4D{Write}} D{}\\
		PC				& D{} 2{4X 8D{Valid}}  X \\
		Instruction		& D{} 12D{Instruction[n]} 12D{Instruction[n+1]} D{} \\
		Register 1 Data	& X 2{ 4X 8D{Valid}} X \\
		Register 2 Data	& X 2{ 4X 8D{Valid}} X \\
		Write Enable	& L 2{4L 4H  4L} L \\
		Branch			& L 2{4L 8D{Valid} } L \\
		\extracode
		\begin{pgfonlayer}{background}
			\begin{scope}[semitransparent ,semithick]
				\vertlines[darkgray,dotted]{1.0,5.0,...,27.0}
			\end{scope}
		\end{pgfonlayer}
	\end{tikztimingtable}
	\caption{Processor timing diagram}
	\label{fig:proc-timing-diagram}
\end{figure}

\begin{figure}[ht]
	\centering
	\def \nodeDist{2.5cm}
	
	\tikzstyle{cycleBlock} = [rectangle, rounded corners, minimum width=\nodeDist, minimum height=\nodeDist, text centered, draw=black, fill=black!40]
	\tikzstyle{normalBlock} = [cycleBlock] %Didn't end up using this in the end
	\tikzstyle{arrowNml} = [thick,->,>=stealth]
	\tikzstyle{arrowRev} = [thick,<-,>=stealth]
	\tikzstyle{arrowDbl} = [thick,<->,>=stealth]
	\tikzstyle{lineNml} = [thick]
	\begin{tikzpicture}[node distance=\nodeDist, scale=0.7, every node/.style={transform shape}]
	
	\newcommand{\buswidth}[5]{\draw ([xshift=#4,yshift=#5] #1) node [#3=.6ex,] {#2} +(45:-.8ex) -- +(45:.8ex)};
	

	% program memory
	\node (progMem) [normalBlock, anchor=south west, minimum height=9cm] at (0,0) {\shortstack{Program\\Memory}};
	
	\draw [arrowRev, draw=green] ( [yshift=-1cm] progMem.west) to node[above] {Cycle} ++(-0.5*\nodeDist,0);
	\buswidth{progMem.west}{$2$}{below}{-0.5*\nodeDist +0.25cm}{-1cm};
	
	\draw [arrowRev, draw=blue] ( progMem.west) to node[above] {Address} ++(-\nodeDist,0) to ++(0,-0.25*\nodeDist - 2cm - 4.5cm) to ++(\nodeDist,0) coordinate(addrLine);
	\buswidth{addrLine}{$5$}{below}{-0.25cm}{0cm};
	
	\draw [arrowNml, draw=blue] ( [yshift=-2cm] progMem.north east) to node[above] {  \shortstack{Register\\Address 1}} ++(\nodeDist,0);
	\buswidth{progMem.north east}{$3$}{below}{0.25cm}{-2cm};
	\draw [arrowNml, draw=blue] ( [yshift=-3cm] progMem.north east) to node[above] {  \shortstack{Register\\Address 2}} ++(\nodeDist,0);
	\buswidth{progMem.north east}{$3$}{below}{0.25cm}{-3cm};
	
	\draw [arrowNml, draw=green] ( [yshift=3cm] progMem.south east) to node[above] {  \shortstack{Opcode}} ++(3*\nodeDist,0);
	\buswidth{progMem.south east}{$1$}{below}{0.25cm}{3cm};
	
	
	% registers
	\node (regs) [cycleBlock, minimum height=5cm, right=of progMem.north east, anchor=north west] {\shortstack{Registers}};
	\draw [arrowNml, draw=red] ( [yshift=-1cm] regs.north east) to node[above] {  \shortstack{Register 1\\Data}} ++(\nodeDist,0);
	\buswidth{regs.north east}{$8$}{below}{0.25cm}{-1cm};
	\draw [arrowNml, draw=red] ( [yshift=-2cm] regs.north east) to node[above] {  \shortstack{Register 2\\Data}} ++(\nodeDist,0);
	\buswidth{regs.north east}{$8$}{below}{0.25cm}{-2cm};
	
	\draw [arrowRev, draw=red] ( [yshift=-1cm] regs.north west) to node[above] {  \shortstack{Write\\Data}} ++(-0.5*\nodeDist,0)  to ++(0,0.5*\nodeDist) to ++(4*\nodeDist,0) to ++(0,-0.5*\nodeDist) to ++(-0.5*\nodeDist,0) coordinate(writeDataEnd);
	\buswidth{writeDataEnd}{$8$}{below}{0.25cm}{0cm};
	\draw [arrowRev, draw=green] ( [yshift=1cm] regs.south west) to node[above] {Cycle} ++(-0.5*\nodeDist,0);
	\buswidth{regs.south west}{$2$}{below}{-0.5*\nodeDist +0.25cm}{1cm};
	
	% alu
	\node (alu) [normalBlock, minimum height=8cm, right=of regs.north east, anchor=north west] {\shortstack{ALU}};
	\draw [arrowRev, draw=red] ( [yshift=1cm] alu.south west) to node[above] {  \shortstack{Immediate}} ++(-1.5*\nodeDist,0) coordinate(aluLineHalfway);
	\draw[lineNml] (aluLineHalfway) -- ++(-1.5*\nodeDist,0) coordinate(aluLineStart);
	\buswidth{aluLineStart}{$5$}{below}{0.25cm}{0cm};
	
	% Program counter
	\node (pc) [cycleBlock, minimum height=4cm, below= 0.25*\nodeDist of progMem.south, anchor=north] {\shortstack{Program\\Address\\Multiplexer}};
	\draw [arrowRev, draw=green] ( [yshift=1cm] pc.south east) to node[above] {Branch} ++(4.5*\nodeDist,0) to ++(0,0.25*\nodeDist +5cm) to ++(-0.5*\nodeDist,0) coordinate(branchEnd);
	\buswidth{branchEnd}{$1$}{below}{0.25cm}{0cm};
	\draw [arrowRev, draw=blue] ( [yshift=2cm] pc.south east) to node[above] {Branch Address} ++(1.5*\nodeDist,0) to ++(0,0.25*\nodeDist +4cm);
	
	\draw [arrowRev, draw=blue] ( [yshift=3cm] pc.south east) to node[above] {Next Address} ++(1*\nodeDist,0) to ++(0,0.25*\nodeDist +2cm) to ++(-1*\nodeDist,0) coordinate(nextAddressEnd);
	\buswidth{nextAddressEnd}{$5$}{below}{0.25cm}{0cm};
	
	% Cycle counter
	\node (cycle) [cycleBlock, minimum height=1.5cm, above= 0.25*\nodeDist of progMem.north, anchor=south] {\shortstack{Cycle\\Counter}};
	\draw [arrowNml, draw=green] (cycle.east) to node[above] {  \shortstack{Cycle}} ++(0.5*\nodeDist,0);
	\buswidth{cycle.east}{$2$}{below}{0.25cm}{0cm};
	
	\end{tikzpicture}
	\caption{Final processor architecture}
	\label{fig:final-proc-arch}
\end{figure}

\subsection{System Level testing} \label{sec:sys-level-testing}.

To test the overall functionality of the system, a testbench was created to simulate switch input, and confirm the output result against a model of the affine transform calculated by the testbench. Using this method, the system was able to be tested for all possible inputs. 

\subsection{Instruction Format}

The processor uses 12 bit instructions. This breaks down into a one bit opcode, two 3 bit register addresses, and a 5 bit immediate / branch address, as shown in Figure \ref{fig:inst-format}. The opcode can be made one bit long because there are only two instructions in the processor, and therefore one bit is enough to differentiate them. The immediate / branch address bits can be shared across the two functions because the MULTI instruction uses an immediate but does not branch, whilst the SUBLEQ instruction does not use an immediate, but can branch. The details of why these two instructions were chosen, and the details of their implementation is given in Section \ref{sec:alu-design}.

\begin{figure}[ht]
	\centering
	\begin{tabularx}{\textwidth}{Y *{16}{|Y}}
		16 & 15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
		\hline
		 {op.} & \multicolumn{3}{c|}{Reg. 1 Addr.} & \multicolumn{3}{c|}{Reg. 2 Addr.} & \multicolumn{5}{c|}{Imm. / Branch Address} & \multicolumn{5}{c}{Next Address} \\
		
	\end{tabularx}
	\caption{Instruction Format and Assembler}
	\label{fig:inst-format}
\end{figure}

A listing of the program used is given in Listing \ref{lst:main-prog}. This is a custom form of assembly code created for this project. Upon reading the source code, the reader will notice that the majority of assembly instructions used are not present as machine instructions on the processor architecture. This is because writing assembly code solely using \texttt{SUBLEQ} and \texttt{MULTI} instructions can be very confusing. For this reason a two-stage compilation toolchain was created using the Python programming language. The first stage takes each assembly instruction that doesn't map into a machine instruction, and re-writes it so that only \texttt{SUBLEQ} and \texttt{MULTI} instructions are used. This is performed by \texttt{optimiser.py}, and the second stage is to compile this assembly code into machine instructions. This is performed by \texttt{assembler.py}. The machine code output by the compilation toolchain is listed in Listing \ref{lst:main-prog-compiled}.

The majority of instructions such as \texttt{MOV} and \texttt{ADD} have their conventional definitions, however there are some slightly more esoteric instructions, namely \texttt{JLEZ}, and \texttt{JGZ}. These are represent `jump if less than or equal to zero', and `jump if greater than or equal to zero' respectively. These instructions are used to poll switch 8. Initially the more conventional \texttt{JZ}, and \texttt{JNZ} (`jump if zero', and `jump if not zero') were used. The system worked with these instructions, however they require more \texttt{SUBLEQ} instructions to implement, and since the switch 8 register is guaranteed to be either $0x00$, or $0x01$ the simpler instructions are functionally equivalent.

\subsection{Program Memory Design}
The program memory block is very simple, it consists solely of a block of synchronous \gls{ram}\, initialised with the data from Listing \ref{lst:main-prog-compiled}. The \gls{ram} was inferred by creating an array of words, and then transferring the addressed word to the output on each rising clock edge, using a non blocking assignment within a rising clock edge \texttt{always} block. This inference approach was taken as opposed to using a dedicated Altera RAM library element because it allows the code to be portable between \gls{fpga} vendors, and an explicit instantiation was not required because compilation with Quartus reveals that the synthesis engine has correctly inferred \gls{ram} from this block.

Due to its simplicity this block was not tested with an individual testbench, and the functionality of the block was verified during system level testing, as described in Section \ref{sec:sys-level-testing}.

\subsection{Program Counter Design}
The program counter consists of three elements: a register to hold the current value of the program counter, a combinational adder to calculate the next value of the program counter if the program does not branch, and a multiplexer to select between the branch address and next instruction. The selected address is clocked into the register on the clock edge after the execute cycle. This in turn allow the program memory to fetch the correct instruction.

\review{This is wrong. We cannot use the RAM register because we cannot read it back, so we need a store of the current PC anyway}
\review{Could mention consideration of storing the program counter in the program code itself}
The register is not strictly necessary in this design in the sense that one could make use of the read enable and asynchronous clear features of the program counter's memory block. This would also remove the need for the `Fetch' cycle in the processor's execution. However the registers do not add to the cost figure of the design, since the logic cells are already being instantiated for the adder. In addition to this, the timing constraints of an asynchronous clear signal to the register input of the memory blocks are complex, and so likely to be violated by the use of a simple switch clear input.

The program counter has a total utilisation of five logic elements for the logic cells containing the adder and counter, and a further multiplier for the multiplexer.

Due to it's simplicity this block was tested using the system level testing, as described in Section \ref{sec:sys-level-testing}, rather than a dedicated testbench.


\review
{
	Provide a block diagram of your picoMIPS design showing the sizes of all the busses and modules.
	
	Describe your picoMIPS instruction format and the instructions you have implemented in your decoder.
	Give a listing of your program implemented in the Program Memory. You can show snippets of your source code.
	There is no need to show the full source code for all your modules in the report as the full source code must be submitted separately.
	Do not copy any code or diagrams from the lectures and picoMIPS SystemVerilog files provided on the ELEC6016 notes site.
	Give your Modelsim testbenches and Modelsim results.
	DO NOT make statements such as: “Figure 2 shows the simulation results of the module functioning correctly”.
	Instead, explain the results shown in the figures to demonstrate that you understand how the tested modules work.
	You can show RTL level diagrams from Quartus if you wish. (max 2.5 pages).
}


\section{General Purpose Register file design, simulation and synthesis}

The register block is the most complex block of the design. At its heart it uses a dual port \gls{ram} block (with one dedicated read port, and one read/write port) to access data. Use of this configuration allows both registers to be read in a single clock cycle, as shown by Figure \ref{fig:proc-timing-diagram}. It should be noted however that the \gls{ram} inside the Cyclone IV \gls{fpga} does not support reading of new data during write, and so this is why there is a dedicated write cycle in the processors execution. Removal of this would result in incorrect data being read if an instruction requested the data from a register that was written to in the previous clock cycle.

The memory map of the registers is shown in Figure \ref{fig:reg-map}. Registers R1--R4 are general purpose computation registers. These are entirely application specific registers, and both reading and writing is legal for any of them. The contents of R4, however, does also map to the \glspl{led} on the \glspl{fpga} development board.

The U register stands for unity. This register is guaranteed to hold the constant necessary for an immediate to be loaded directly into a register using the \texttt{MULTI} command. This is necessary because by default immediates are treated as being a fractional constant, as discussed in Section \ref{sec:alu-design}. It is forbidden for any program to write to this value, as doing so will break the \texttt{LDI} (load immediate) command. The value of this register is initialised by the bitstream only, and resetting the processor using the reset switch will not reset its value. It should be noted that writing to this register is not prevented in hardware, but it is forbidden for any program to do so.

The Z register stands for zero. The value of this register is kept at zero, and writing to it should be done with extreme caution. Many of the higher level assembly commands internally rely on this register being zero when they are replaced with calls to \texttt{SUBLEQ}, and \texttt{MULTI}. Writing to Z, however, is not forbidden entirely as many of these higher level commands use it as a general purpose computation register, but they all guarantee to clear Z back to zero before exiting. Z is not initialised to zero by the bitstream, but instead the first command of the program must be \texttt{SUBLEQ Z Z} in order to clear it. This approach is taken so that the processor still functions correctly if it is reset using the reset switch whilst Z is non-zero.

The SW07 and SW8 registers are different from the others in that they do not map to internal storage in the \gls{fpga}. When the program attempts to read their value the value of switches 0--7, or switch 8 is returned instead, this is achieved by multiplexing the data outputs of the register bank. There do exist, however, registers inside the register memory at the addresses of the switch registers, this is because writing to the SW07 and SW8 registers is legal, but has no effect, physical registers need to exist in order to avoid an out of range write.
\review{Do they? Maybe I can reduce my register size slightly?}


\begin{figure}[ht]
	\centering
	\begin{tabular}{r | l}
		Address & Mnemonic \\
		\hline
		0x0	& R1 \\
		0x1	& R2 \\
		0x2	& R3 \\
		0x3	& R4 / LED \\
		0x4	& U \\
		0x5	& Z \\
		0x6	& SW07 \\
		0x7	& SW8 \\
	\end{tabular}
	\caption{Register map}
	\label{fig:reg-map}
\end{figure}

\begin{figure}[ht]
	\centering
	\def \nodeDist{2.5cm}
	\tikzstyle{normalBlock} = [rectangle, rounded corners, minimum width=\nodeDist, minimum height=\nodeDist, text centered, draw=black, fill=black!40]
	\tikzstyle{arrowNml} = [thick,->,>=stealth]
	\tikzstyle{arrowRev} = [thick,<-,>=stealth]
	\tikzstyle{arrowDbl} = [thick,<->,>=stealth]
	\tikzstyle{lineNml} = [thick]
	\begin{tikzpicture}[node distance=\nodeDist, scale=0.7, every node/.style={transform shape}]
	
	\newcommand{\buswidth}[5]{\draw ([xshift=#4,yshift=#5] #1) node [#3=.6ex,] {#2} +(45:-.8ex) -- +(45:.8ex)};
	
	
	% program memory
	\node (mem) [normalBlock, minimum height=9cm] at (0,0) {\shortstack{Register\\Memory}};
	\coordinate (addr1) at ([yshift=-1cm] mem.north west);
	\draw [arrowRev] (addr1) to node[above] (foo) {Address 1} ++(-\nodeDist,0);
	\buswidth{addr1}{$3$}{below}{-0.5cm}{0};
	
	\end{tikzpicture}
	\caption{Register memory architecture}
	\label{fig:reg-mem-arch}
\end{figure}

\review
{
	As above (max 1.5 page)
}

\section{Arithmetic Logic Unit and Mulitiplier Design} \label{sec:alu-design}.
\review
{
	 Explain the functions implemented in  your ALU and explain your testbench. Show Modelsim test results.  If you have implemented a hardware multiplier (or multipliers), explain your multiplier design and give Modelsim test results. State if your multiplier module synthesised as an embedded hardware multiplier.  (approx. 1.5- 2 pages)
}

\section{Altera DE0 implementation} \label{sec:implementation}
\review
{
	Explain how you tested your design after  programming the FPGA. In case you had to edit your original code and resynthesize – explain what you did.  ( approx. 1-2 pages)
}

\section{Conclusion}
\review
{
	State which objectives listed in your Introducton have been achieved. Calculate the cost figure of your design for synthesis on a Cyclone IV E.. Give your general  conclusion, comment on what you learnt.  Comment on ways to improve the design or extend it further.  ( approx.0.25 – 0.5 of a page)
}